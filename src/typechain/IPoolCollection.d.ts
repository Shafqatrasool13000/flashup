/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface IPoolCollectionInterface extends ethers.utils.Interface {
  functions: {
    "createPool(address)": FunctionFragment;
    "defaultTradingFeePPM()": FunctionFragment;
    "depositFor(bytes32,address,address,uint256)": FunctionFragment;
    "depositingEnabled(address)": FunctionFragment;
    "isPoolStable(address)": FunctionFragment;
    "isPoolValid(address)": FunctionFragment;
    "migratePoolIn(address,(address,uint32,bool,bool,(uint32,(uint112,uint112),(uint112,uint112)),(uint128,uint128,uint256)))": FunctionFragment;
    "migratePoolOut(address,address)": FunctionFragment;
    "networkFeePPM()": FunctionFragment;
    "onFeesCollected(address,uint256)": FunctionFragment;
    "poolCount()": FunctionFragment;
    "poolLiquidity(address)": FunctionFragment;
    "poolToken(address)": FunctionFragment;
    "poolTokenAmountToBurn(address,uint256,uint256)": FunctionFragment;
    "poolTokenToUnderlying(address,uint256)": FunctionFragment;
    "poolType()": FunctionFragment;
    "pools()": FunctionFragment;
    "tradeBySourceAmount(bytes32,address,address,uint256,uint256)": FunctionFragment;
    "tradeByTargetAmount(bytes32,address,address,uint256,uint256)": FunctionFragment;
    "tradeInputAndFeeByTargetAmount(address,address,uint256)": FunctionFragment;
    "tradeOutputAndFeeBySourceAmount(address,address,uint256)": FunctionFragment;
    "tradingEnabled(address)": FunctionFragment;
    "tradingFeePPM(address)": FunctionFragment;
    "underlyingToPoolToken(address,uint256)": FunctionFragment;
    "version()": FunctionFragment;
    "withdraw(bytes32,address,address,uint256,uint256)": FunctionFragment;
    "withdrawalAmounts(address,uint256)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "createPool", values: [string]): string;
  encodeFunctionData(
    functionFragment: "defaultTradingFeePPM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "depositFor",
    values: [BytesLike, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "depositingEnabled",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "isPoolStable",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "isPoolValid", values: [string]): string;
  encodeFunctionData(
    functionFragment: "migratePoolIn",
    values: [
      string,
      {
        poolToken: string;
        tradingFeePPM: BigNumberish;
        tradingEnabled: boolean;
        depositingEnabled: boolean;
        averageRates: {
          blockNumber: BigNumberish;
          rate: { n: BigNumberish; d: BigNumberish };
          invRate: { n: BigNumberish; d: BigNumberish };
        };
        liquidity: {
          bntTradingLiquidity: BigNumberish;
          baseTokenTradingLiquidity: BigNumberish;
          stakedBalance: BigNumberish;
        };
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "migratePoolOut",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "networkFeePPM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "onFeesCollected",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "poolCount", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "poolLiquidity",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "poolToken", values: [string]): string;
  encodeFunctionData(
    functionFragment: "poolTokenAmountToBurn",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "poolTokenToUnderlying",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "poolType", values?: undefined): string;
  encodeFunctionData(functionFragment: "pools", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "tradeBySourceAmount",
    values: [BytesLike, string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tradeByTargetAmount",
    values: [BytesLike, string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tradeInputAndFeeByTargetAmount",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tradeOutputAndFeeBySourceAmount",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "tradingEnabled",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "tradingFeePPM",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "underlyingToPoolToken",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [BytesLike, string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawalAmounts",
    values: [string, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "createPool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "defaultTradingFeePPM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "depositingEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isPoolStable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isPoolValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "migratePoolIn",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "migratePoolOut",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "networkFeePPM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onFeesCollected",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "poolCount", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "poolLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "poolToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "poolTokenAmountToBurn",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "poolTokenToUnderlying",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "poolType", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pools", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "tradeBySourceAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradeByTargetAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradeInputAndFeeByTargetAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradeOutputAndFeeBySourceAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradingEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradingFeePPM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "underlyingToPoolToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawalAmounts",
    data: BytesLike
  ): Result;

  events: {};
}

export class IPoolCollection extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: IPoolCollectionInterface;

  functions: {
    createPool(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    defaultTradingFeePPM(overrides?: CallOverrides): Promise<[number]>;

    depositFor(
      contextId: BytesLike,
      provider: string,
      pool: string,
      baseTokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    depositingEnabled(
      pool: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isPoolStable(pool: string, overrides?: CallOverrides): Promise<[boolean]>;

    isPoolValid(pool: string, overrides?: CallOverrides): Promise<[boolean]>;

    migratePoolIn(
      pool: string,
      data: {
        poolToken: string;
        tradingFeePPM: BigNumberish;
        tradingEnabled: boolean;
        depositingEnabled: boolean;
        averageRates: {
          blockNumber: BigNumberish;
          rate: { n: BigNumberish; d: BigNumberish };
          invRate: { n: BigNumberish; d: BigNumberish };
        };
        liquidity: {
          bntTradingLiquidity: BigNumberish;
          baseTokenTradingLiquidity: BigNumberish;
          stakedBalance: BigNumberish;
        };
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    migratePoolOut(
      pool: string,
      targetPoolCollection: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    networkFeePPM(overrides?: CallOverrides): Promise<[number]>;

    onFeesCollected(
      pool: string,
      feeAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    poolCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    poolLiquidity(
      pool: string,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber, BigNumber, BigNumber] & {
          bntTradingLiquidity: BigNumber;
          baseTokenTradingLiquidity: BigNumber;
          stakedBalance: BigNumber;
        }
      ]
    >;

    poolToken(pool: string, overrides?: CallOverrides): Promise<[string]>;

    poolTokenAmountToBurn(
      pool: string,
      baseTokenAmountToDistribute: BigNumberish,
      protocolPoolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    poolTokenToUnderlying(
      pool: string,
      poolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    poolType(overrides?: CallOverrides): Promise<[number]>;

    pools(overrides?: CallOverrides): Promise<[string[]]>;

    tradeBySourceAmount(
      contextId: BytesLike,
      sourceToken: string,
      targetToken: string,
      sourceAmount: BigNumberish,
      minReturnAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tradeByTargetAmount(
      contextId: BytesLike,
      sourceToken: string,
      targetToken: string,
      targetAmount: BigNumberish,
      maxSourceAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tradeInputAndFeeByTargetAmount(
      sourceToken: string,
      targetToken: string,
      targetAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber, BigNumber, BigNumber] & {
          amount: BigNumber;
          tradingFeeAmount: BigNumber;
          networkFeeAmount: BigNumber;
        }
      ]
    >;

    tradeOutputAndFeeBySourceAmount(
      sourceToken: string,
      targetToken: string,
      sourceAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber, BigNumber, BigNumber] & {
          amount: BigNumber;
          tradingFeeAmount: BigNumber;
          networkFeeAmount: BigNumber;
        }
      ]
    >;

    tradingEnabled(pool: string, overrides?: CallOverrides): Promise<[boolean]>;

    tradingFeePPM(pool: string, overrides?: CallOverrides): Promise<[number]>;

    underlyingToPoolToken(
      pool: string,
      baseTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    version(overrides?: CallOverrides): Promise<[number]>;

    withdraw(
      contextId: BytesLike,
      provider: string,
      pool: string,
      poolTokenAmount: BigNumberish,
      baseTokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdrawalAmounts(
      pool: string,
      poolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber, BigNumber, BigNumber] & {
          totalAmount: BigNumber;
          baseTokenAmount: BigNumber;
          bntAmount: BigNumber;
        }
      ]
    >;
  };

  createPool(
    token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  defaultTradingFeePPM(overrides?: CallOverrides): Promise<number>;

  depositFor(
    contextId: BytesLike,
    provider: string,
    pool: string,
    baseTokenAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  depositingEnabled(pool: string, overrides?: CallOverrides): Promise<boolean>;

  isPoolStable(pool: string, overrides?: CallOverrides): Promise<boolean>;

  isPoolValid(pool: string, overrides?: CallOverrides): Promise<boolean>;

  migratePoolIn(
    pool: string,
    data: {
      poolToken: string;
      tradingFeePPM: BigNumberish;
      tradingEnabled: boolean;
      depositingEnabled: boolean;
      averageRates: {
        blockNumber: BigNumberish;
        rate: { n: BigNumberish; d: BigNumberish };
        invRate: { n: BigNumberish; d: BigNumberish };
      };
      liquidity: {
        bntTradingLiquidity: BigNumberish;
        baseTokenTradingLiquidity: BigNumberish;
        stakedBalance: BigNumberish;
      };
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  migratePoolOut(
    pool: string,
    targetPoolCollection: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  networkFeePPM(overrides?: CallOverrides): Promise<number>;

  onFeesCollected(
    pool: string,
    feeAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  poolCount(overrides?: CallOverrides): Promise<BigNumber>;

  poolLiquidity(
    pool: string,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      bntTradingLiquidity: BigNumber;
      baseTokenTradingLiquidity: BigNumber;
      stakedBalance: BigNumber;
    }
  >;

  poolToken(pool: string, overrides?: CallOverrides): Promise<string>;

  poolTokenAmountToBurn(
    pool: string,
    baseTokenAmountToDistribute: BigNumberish,
    protocolPoolTokenAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  poolTokenToUnderlying(
    pool: string,
    poolTokenAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  poolType(overrides?: CallOverrides): Promise<number>;

  pools(overrides?: CallOverrides): Promise<string[]>;

  tradeBySourceAmount(
    contextId: BytesLike,
    sourceToken: string,
    targetToken: string,
    sourceAmount: BigNumberish,
    minReturnAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tradeByTargetAmount(
    contextId: BytesLike,
    sourceToken: string,
    targetToken: string,
    targetAmount: BigNumberish,
    maxSourceAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tradeInputAndFeeByTargetAmount(
    sourceToken: string,
    targetToken: string,
    targetAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      amount: BigNumber;
      tradingFeeAmount: BigNumber;
      networkFeeAmount: BigNumber;
    }
  >;

  tradeOutputAndFeeBySourceAmount(
    sourceToken: string,
    targetToken: string,
    sourceAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      amount: BigNumber;
      tradingFeeAmount: BigNumber;
      networkFeeAmount: BigNumber;
    }
  >;

  tradingEnabled(pool: string, overrides?: CallOverrides): Promise<boolean>;

  tradingFeePPM(pool: string, overrides?: CallOverrides): Promise<number>;

  underlyingToPoolToken(
    pool: string,
    baseTokenAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  version(overrides?: CallOverrides): Promise<number>;

  withdraw(
    contextId: BytesLike,
    provider: string,
    pool: string,
    poolTokenAmount: BigNumberish,
    baseTokenAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdrawalAmounts(
    pool: string,
    poolTokenAmount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      totalAmount: BigNumber;
      baseTokenAmount: BigNumber;
      bntAmount: BigNumber;
    }
  >;

  callStatic: {
    createPool(token: string, overrides?: CallOverrides): Promise<void>;

    defaultTradingFeePPM(overrides?: CallOverrides): Promise<number>;

    depositFor(
      contextId: BytesLike,
      provider: string,
      pool: string,
      baseTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    depositingEnabled(
      pool: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isPoolStable(pool: string, overrides?: CallOverrides): Promise<boolean>;

    isPoolValid(pool: string, overrides?: CallOverrides): Promise<boolean>;

    migratePoolIn(
      pool: string,
      data: {
        poolToken: string;
        tradingFeePPM: BigNumberish;
        tradingEnabled: boolean;
        depositingEnabled: boolean;
        averageRates: {
          blockNumber: BigNumberish;
          rate: { n: BigNumberish; d: BigNumberish };
          invRate: { n: BigNumberish; d: BigNumberish };
        };
        liquidity: {
          bntTradingLiquidity: BigNumberish;
          baseTokenTradingLiquidity: BigNumberish;
          stakedBalance: BigNumberish;
        };
      },
      overrides?: CallOverrides
    ): Promise<void>;

    migratePoolOut(
      pool: string,
      targetPoolCollection: string,
      overrides?: CallOverrides
    ): Promise<void>;

    networkFeePPM(overrides?: CallOverrides): Promise<number>;

    onFeesCollected(
      pool: string,
      feeAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    poolCount(overrides?: CallOverrides): Promise<BigNumber>;

    poolLiquidity(
      pool: string,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        bntTradingLiquidity: BigNumber;
        baseTokenTradingLiquidity: BigNumber;
        stakedBalance: BigNumber;
      }
    >;

    poolToken(pool: string, overrides?: CallOverrides): Promise<string>;

    poolTokenAmountToBurn(
      pool: string,
      baseTokenAmountToDistribute: BigNumberish,
      protocolPoolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    poolTokenToUnderlying(
      pool: string,
      poolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    poolType(overrides?: CallOverrides): Promise<number>;

    pools(overrides?: CallOverrides): Promise<string[]>;

    tradeBySourceAmount(
      contextId: BytesLike,
      sourceToken: string,
      targetToken: string,
      sourceAmount: BigNumberish,
      minReturnAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amount: BigNumber;
        tradingFeeAmount: BigNumber;
        networkFeeAmount: BigNumber;
      }
    >;

    tradeByTargetAmount(
      contextId: BytesLike,
      sourceToken: string,
      targetToken: string,
      targetAmount: BigNumberish,
      maxSourceAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amount: BigNumber;
        tradingFeeAmount: BigNumber;
        networkFeeAmount: BigNumber;
      }
    >;

    tradeInputAndFeeByTargetAmount(
      sourceToken: string,
      targetToken: string,
      targetAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amount: BigNumber;
        tradingFeeAmount: BigNumber;
        networkFeeAmount: BigNumber;
      }
    >;

    tradeOutputAndFeeBySourceAmount(
      sourceToken: string,
      targetToken: string,
      sourceAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        amount: BigNumber;
        tradingFeeAmount: BigNumber;
        networkFeeAmount: BigNumber;
      }
    >;

    tradingEnabled(pool: string, overrides?: CallOverrides): Promise<boolean>;

    tradingFeePPM(pool: string, overrides?: CallOverrides): Promise<number>;

    underlyingToPoolToken(
      pool: string,
      baseTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<number>;

    withdraw(
      contextId: BytesLike,
      provider: string,
      pool: string,
      poolTokenAmount: BigNumberish,
      baseTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawalAmounts(
      pool: string,
      poolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        totalAmount: BigNumber;
        baseTokenAmount: BigNumber;
        bntAmount: BigNumber;
      }
    >;
  };

  filters: {};

  estimateGas: {
    createPool(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    defaultTradingFeePPM(overrides?: CallOverrides): Promise<BigNumber>;

    depositFor(
      contextId: BytesLike,
      provider: string,
      pool: string,
      baseTokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    depositingEnabled(
      pool: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isPoolStable(pool: string, overrides?: CallOverrides): Promise<BigNumber>;

    isPoolValid(pool: string, overrides?: CallOverrides): Promise<BigNumber>;

    migratePoolIn(
      pool: string,
      data: {
        poolToken: string;
        tradingFeePPM: BigNumberish;
        tradingEnabled: boolean;
        depositingEnabled: boolean;
        averageRates: {
          blockNumber: BigNumberish;
          rate: { n: BigNumberish; d: BigNumberish };
          invRate: { n: BigNumberish; d: BigNumberish };
        };
        liquidity: {
          bntTradingLiquidity: BigNumberish;
          baseTokenTradingLiquidity: BigNumberish;
          stakedBalance: BigNumberish;
        };
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    migratePoolOut(
      pool: string,
      targetPoolCollection: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    networkFeePPM(overrides?: CallOverrides): Promise<BigNumber>;

    onFeesCollected(
      pool: string,
      feeAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    poolCount(overrides?: CallOverrides): Promise<BigNumber>;

    poolLiquidity(pool: string, overrides?: CallOverrides): Promise<BigNumber>;

    poolToken(pool: string, overrides?: CallOverrides): Promise<BigNumber>;

    poolTokenAmountToBurn(
      pool: string,
      baseTokenAmountToDistribute: BigNumberish,
      protocolPoolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    poolTokenToUnderlying(
      pool: string,
      poolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    poolType(overrides?: CallOverrides): Promise<BigNumber>;

    pools(overrides?: CallOverrides): Promise<BigNumber>;

    tradeBySourceAmount(
      contextId: BytesLike,
      sourceToken: string,
      targetToken: string,
      sourceAmount: BigNumberish,
      minReturnAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tradeByTargetAmount(
      contextId: BytesLike,
      sourceToken: string,
      targetToken: string,
      targetAmount: BigNumberish,
      maxSourceAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tradeInputAndFeeByTargetAmount(
      sourceToken: string,
      targetToken: string,
      targetAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tradeOutputAndFeeBySourceAmount(
      sourceToken: string,
      targetToken: string,
      sourceAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tradingEnabled(pool: string, overrides?: CallOverrides): Promise<BigNumber>;

    tradingFeePPM(pool: string, overrides?: CallOverrides): Promise<BigNumber>;

    underlyingToPoolToken(
      pool: string,
      baseTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    version(overrides?: CallOverrides): Promise<BigNumber>;

    withdraw(
      contextId: BytesLike,
      provider: string,
      pool: string,
      poolTokenAmount: BigNumberish,
      baseTokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdrawalAmounts(
      pool: string,
      poolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    createPool(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    defaultTradingFeePPM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    depositFor(
      contextId: BytesLike,
      provider: string,
      pool: string,
      baseTokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    depositingEnabled(
      pool: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isPoolStable(
      pool: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isPoolValid(
      pool: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    migratePoolIn(
      pool: string,
      data: {
        poolToken: string;
        tradingFeePPM: BigNumberish;
        tradingEnabled: boolean;
        depositingEnabled: boolean;
        averageRates: {
          blockNumber: BigNumberish;
          rate: { n: BigNumberish; d: BigNumberish };
          invRate: { n: BigNumberish; d: BigNumberish };
        };
        liquidity: {
          bntTradingLiquidity: BigNumberish;
          baseTokenTradingLiquidity: BigNumberish;
          stakedBalance: BigNumberish;
        };
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    migratePoolOut(
      pool: string,
      targetPoolCollection: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    networkFeePPM(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    onFeesCollected(
      pool: string,
      feeAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    poolCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolLiquidity(
      pool: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    poolToken(
      pool: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    poolTokenAmountToBurn(
      pool: string,
      baseTokenAmountToDistribute: BigNumberish,
      protocolPoolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    poolTokenToUnderlying(
      pool: string,
      poolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    poolType(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pools(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tradeBySourceAmount(
      contextId: BytesLike,
      sourceToken: string,
      targetToken: string,
      sourceAmount: BigNumberish,
      minReturnAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tradeByTargetAmount(
      contextId: BytesLike,
      sourceToken: string,
      targetToken: string,
      targetAmount: BigNumberish,
      maxSourceAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tradeInputAndFeeByTargetAmount(
      sourceToken: string,
      targetToken: string,
      targetAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tradeOutputAndFeeBySourceAmount(
      sourceToken: string,
      targetToken: string,
      sourceAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tradingEnabled(
      pool: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tradingFeePPM(
      pool: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    underlyingToPoolToken(
      pool: string,
      baseTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdraw(
      contextId: BytesLike,
      provider: string,
      pool: string,
      poolTokenAmount: BigNumberish,
      baseTokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdrawalAmounts(
      pool: string,
      poolTokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
